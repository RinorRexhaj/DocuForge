"""
Test Script: Blur Detection for Forgery.py Generated Images
============================================================
This script tests the enhanced blur/smudge detection on synthetic forgeries
created by your Forgery.py script.
"""

import os
import sys
import cv2
import numpy as np
import torch
from pathlib import Path
import matplotlib.pyplot as plt

# Add server directory to path
sys.path.insert(0, str(Path(__file__).parent.parent))

# Import tampering detection
from detection.tampering_localization import detect_tampering_hybrid, DocumentTamperingDetector


def test_on_forgery_dataset(forgery_dir="E:\\Thesis\\forgery_dataset_realistic", 
                            model_path=None,
                            num_samples=5):
    if model_path is None:
        model_path = str(Path(__file__).parent.parent / "models" / "saved_models" / "best_model.pth")
    """
    Test blur detection on images generated by Forgery.py.
    
    Args:
        forgery_dir: Path to forgery dataset
        model_path: Path to trained model
        num_samples: Number of samples to test
    """
    
    print("\n" + "="*70)
    print("Testing Enhanced Blur Detection on Forgery.py Generated Images")
    print("="*70 + "\n")
    
    # Check if forgery dataset exists
    if not os.path.exists(forgery_dir):
        print(f"⚠️  Forgery dataset not found at: {forgery_dir}")
        print("Please update the path or generate forgeries using Forgery.py first.")
        return
    
    # Load model
    if not os.path.exists(model_path):
        print(f"⚠️  Model not found at: {model_path}")
        print("Creating a dummy model for testing...")
        
        # Create dummy model for testing
        import torch.nn as nn
        class DummyModel(nn.Module):
            def __init__(self):
                super().__init__()
                self.conv1 = nn.Conv2d(3, 64, 7, stride=2, padding=3)
                self.layer4 = nn.Sequential(nn.Conv2d(64, 512, 3, padding=1))
                self.fc = nn.Linear(512, 2)
            
            def forward(self, x):
                x = self.conv1(x)
                x = self.layer4(x)
                x = torch.nn.functional.adaptive_avg_pool2d(x, 1)
                x = x.view(x.size(0), -1)
                x = self.fc(x)
                return x
        
        model = DummyModel()
        model.eval()
    else:
        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        model = torch.load(model_path, map_location=device)
        model.eval()
        print(f"✓ Model loaded from: {model_path}")
    
    # Find forged images
    forged_dir = Path(forgery_dir)
    train_forged = forged_dir / "train" / "forged"
    test_forged = forged_dir / "test" / "forged"
    val_forged = forged_dir / "val" / "forged"
    
    # Collect image paths
    image_paths = []
    for directory in [train_forged, test_forged, val_forged]:
        if directory.exists():
            for ext in ['*.jpg', '*.jpeg', '*.png']:
                image_paths.extend(list(directory.glob(ext)))
    
    if not image_paths:
        print("❌ No forged images found in dataset!")
        return
    
    print(f"Found {len(image_paths)} forged images")
    print(f"Testing on {min(num_samples, len(image_paths))} samples...\n")
    
    # Test on samples
    results = []
    
    for i, img_path in enumerate(image_paths[:num_samples], 1):
        print(f"\n{'='*70}")
        print(f"Sample {i}/{min(num_samples, len(image_paths))}: {img_path.name}")
        print(f"{'='*70}")
        
        try:
            # Run detection with enhanced blur detection
            result = detect_tampering_hybrid(
                image_path=str(img_path),
                model=model,
                device="cuda" if torch.cuda.is_available() else "cpu",
                save_results=True,
                sensitivity=0.4,  # Lower sensitivity to catch blur artifacts
                return_intermediate_maps=True
            )
            
            results.append({
                'path': str(img_path),
                'probability': result['probability'],
                'num_regions': len(result['bboxes']),
                'has_blur_detection': 'blur_combined' in result.get('intermediate_maps', {})
            })
            
            # Display blur-specific results
            if 'intermediate_maps' in result:
                blur_maps = {k: v for k, v in result['intermediate_maps'].items() if k.startswith('blur_')}
                if blur_maps:
                    print(f"\n📊 Blur Detection Results:")
                    for name, blur_map in blur_maps.items():
                        if isinstance(blur_map, np.ndarray):
                            mean_score = float(np.mean(blur_map))
                            max_score = float(np.max(blur_map))
                            print(f"  - {name:25s}: mean={mean_score:.3f}, max={max_score:.3f}")
            
            print(f"\n✅ Overall Probability: {result['probability']:.2%}")
            print(f"   Detected Regions: {len(result['bboxes'])}")
            
        except Exception as e:
            print(f"❌ Error processing {img_path.name}: {e}")
            import traceback
            traceback.print_exc()
    
    # Summary
    print(f"\n{'='*70}")
    print("DETECTION SUMMARY")
    print(f"{'='*70}\n")
    
    if results:
        avg_prob = np.mean([r['probability'] for r in results])
        avg_regions = np.mean([r['num_regions'] for r in results])
        with_blur = sum(1 for r in results if r['has_blur_detection'])
        
        print(f"Total Images Tested: {len(results)}")
        print(f"Average Tampering Probability: {avg_prob:.2%}")
        print(f"Average Detected Regions: {avg_regions:.1f}")
        print(f"Images with Enhanced Blur Detection: {with_blur}/{len(results)}")
        
        # Show distribution
        high_prob = sum(1 for r in results if r['probability'] > 0.7)
        medium_prob = sum(1 for r in results if 0.4 <= r['probability'] <= 0.7)
        low_prob = sum(1 for r in results if r['probability'] < 0.4)
        
        print(f"\nProbability Distribution:")
        print(f"  High (>70%):    {high_prob}/{len(results)}")
        print(f"  Medium (40-70%): {medium_prob}/{len(results)}")
        print(f"  Low (<40%):     {low_prob}/{len(results)}")
    
    print(f"\n✅ Testing completed!")
    print(f"Results saved to: tampering_results/")


def visualize_blur_detection_comparison(image_path, model):
    """
    Create a detailed comparison visualization showing all blur detection techniques.
    
    Args:
        image_path: Path to forged image
        model: Trained model
    """
    print("\n" + "="*70)
    print("Creating Detailed Blur Detection Visualization")
    print("="*70 + "\n")
    
    # Run detection
    result = detect_tampering_hybrid(
        image_path=image_path,
        model=model,
        device="cuda" if torch.cuda.is_available() else "cpu",
        save_results=False,
        return_intermediate_maps=True
    )
    
    # Load original image
    img = cv2.imread(image_path)
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    
    # Extract blur-related maps
    intermediate = result.get('intermediate_maps', {})
    blur_maps = {k.replace('blur_', ''): v for k, v in intermediate.items() if k.startswith('blur_')}
    
    # Create visualization
    num_maps = len(blur_maps) + 2  # Original + Final + blur maps
    cols = 3
    rows = (num_maps + cols - 1) // cols
    
    fig, axes = plt.subplots(rows, cols, figsize=(15, 5 * rows))
    axes = axes.flatten() if isinstance(axes, np.ndarray) else [axes]
    
    # Original image
    axes[0].imshow(img_rgb)
    axes[0].set_title("Original Forged Image", fontsize=12, fontweight='bold')
    axes[0].axis('off')
    
    # Individual blur detection maps
    idx = 1
    for name, blur_map in blur_maps.items():
        if isinstance(blur_map, np.ndarray) and blur_map.size > 0:
            axes[idx].imshow(blur_map, cmap='hot')
            axes[idx].set_title(f"{name.replace('_', ' ').title()}", fontsize=10)
            axes[idx].axis('off')
            idx += 1
    
    # Final combined result
    if idx < len(axes):
        axes[idx].imshow(result['heatmap'])
        axes[idx].set_title("Final Combined Detection", fontsize=12, fontweight='bold')
        axes[idx].axis('off')
        idx += 1
    
    # Hide unused subplots
    for i in range(idx, len(axes)):
        axes[i].axis('off')
    
    plt.tight_layout()
    
    # Save
    output_path = "tampering_results/blur_detection_comparison.png"
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    print(f"✓ Visualization saved to: {output_path}")
    
    plt.close()


def main():
    """Run all tests."""
    
    # Test 1: Batch testing on forgery dataset
    test_on_forgery_dataset(
        forgery_dir="E:\\Thesis\\forgery_dataset_realistic",
        model_path="saved_models/best_model.pth",
        num_samples=5
    )
    
    # Test 2: Detailed visualization (if forgery dataset exists)
    forgery_dir = Path("E:\\Thesis\\forgery_dataset_realistic")
    train_forged = forgery_dir / "train" / "forged"
    
    if train_forged.exists():
        sample_images = list(train_forged.glob("*.jpg"))
        if sample_images:
            print("\n" + "="*70)
            print("Creating detailed visualization for first sample...")
            print("="*70)
            
            try:
                model_path = "saved_models/best_model.pth"
                if os.path.exists(model_path):
                    model = torch.load(model_path)
                else:
                    # Dummy model
                    import torch.nn as nn
                    class DummyModel(nn.Module):
                        def __init__(self):
                            super().__init__()
                            self.conv1 = nn.Conv2d(3, 64, 7)
                            self.layer4 = nn.Sequential(nn.Conv2d(64, 512, 3))
                            self.fc = nn.Linear(512, 2)
                        def forward(self, x):
                            return self.fc(torch.flatten(x, 1))
                    model = DummyModel()
                
                model.eval()
                visualize_blur_detection_comparison(str(sample_images[0]), model)
                
            except Exception as e:
                print(f"⚠️  Visualization failed: {e}")


if __name__ == "__main__":
    main()
